# """
#     This file is part of b26_toolkit, a pylabcontrol add-on for experiments in Harvard LISE B26.
#     Copyright (C) <2016>  Arthur Safira, Jan Gieseler, Aaron Kabcenell

#     b26_toolkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     b26_toolkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with b26_toolkit.  If not, see <http://www.gnu.org/licenses/>.
# """


import pyvisa as visa
import nidaqmx, time
import sys
from qcodes.instrument.base import Instrument
from qcodes.instrument.parameter import Parameter

class Velocity():
    def __init__(self, name='Velocity_6304H', velNum=1, ifInitVpz=1, ifInitWvl=0, initWvl=637, **kwargs) -> None:
        rm = visa.ResourceManager()
    
        if velNum==1: self.vel = rm.open_resource('GPIB0::2::INSTR')
        elif velNum==2: self.vel = rm.open_resource('GPIB0::1::INSTR')
        self.vel.baud_rate = 19200
        self.vel.query('*IDN?')

        if ifInitWvl: 
            self.set_track()
            time.sleep(0.5)
            self.set_wvl(initWvl)
            time.sleep(1)
            self.set_ready()
            self.set_vpiezo(50)
            self.waitUntilComplete()
            self.set_ready()
            time.sleep(0.7)
        if ifInitVpz:
            self.set_vpiezo(50)
            self.waitUntilComplete()
            self.set_ready()
            time.sleep(0.7)

    def checkIfComplete(self):
        return(int(self.vel.query('*OPC?')))
        # if int(err) == 0:
        #     print('Operation NOT completed')
        # elif int(err) == 1: print('Operation completed')

    def waitUntilComplete(self):
        while True:
            state = self.checkIfComplete()
            if state == 1: break

    
    def enable_output(self):
        self.vel.write('OUTPut:STATe 1')
        
    def disable_output(self):
        self.vel.write('OUTPut:STATe 0')
        
    ###########################################################################################
    
    def set_power(self, P):
        # P in mW
        self.vel.write('SOURce:CPOWer 1')
        self.vel.write('SOURce:POWer {}'.format(P))
        P_current = self.vel.query('sense:power:front')
        return print('P_current = {} mW'.format(P_current))

    def set_wvl(self, λ):
        # λ in nm
        self.vel.write('SOURce:WAVElength {}'.format(λ))
        # self.vel.write('OUTPut:TRACK 1')
        λ_current = self.vel.query('SOURCE:WAVELENGTH?')
        return print('λ_current = {} nm'.format(λ_current))
    
    def set_vpiezo(self, v):
        self.vel.write('SOURce:VOLTage:PIEZo {}'.format(v))
        v_current = self.vel.query('SOURce:VOLTage:PIEZo?')
        return print('vpiezo_current = {} V'.format(v_current))
    
    def set_current(self, I):
        # I in mA
        self.vel.write('SOURce:CURRent:DIODe {}'.format(I))
        I_current = self.vel.query('SOURce:CURRent:DIODe?')
        return print('I_current = {} mA'.format(I_current))
    
    def set_temp(self, T):
        # T in C
        self.vel.write('SOURce:temperature:DIODe {}'.format(T))
        T_current = self.vel.query('SOURce:temperature:DIODe?')
        return print('T_current = {} C'.format(T_current))
    
    ##########################################################################################
    def meas_power_front(self):
        P = self.vel.write('SENSe:power:front')
        print('P = {} mW'.format(P))
        return P
    
    def meas_power_rear(self):
        P = self.vel.write('SENSe:power:rear')
        print('P = {} mW'.format(P))
        return P
    
    def meas_vpiezo(self):
        v = self.vel.write('SENSe:VOLTage:piezo')
        print('V = {} V'.format(v))
        return v
    
    def meas_current(self):
        i = self.vel.write('SENSe:CURRent:DIODe')
        print('I = {} mA'.format(i))
        return i
    
    def meas_temp_setpoint_diode(self):
        temp = self.vel.write('SENSe:TEMPerature:setpoint:DIODe')
        print('Diode setpoint temp = {} C'.format(temp))
        return temp
    def meas_temp_setpoint_cavity(self):
        temp = self.vel.write('SENSe:TEMPerature:setpoint:cavity')
        print('Cavity setpoint temp = {} C'.format(temp))
        return temp
    def meas_temp_diode(self):
        temp = self.vel.write('source:TEMPerature:DIODe?')
        print('Diode temp = {} C'.format(temp))
        return temp
    
    def meas_wvl(self):
        wvl = self.vel.write('SENSe:WAVElength')
        print('Wavelength = {} nm'.format(wvl))
        return wvl
    
    ##########################################################################################     
    def set_scan_limits(self, λi, λf):
        # λi, λf in nm
        self.vel.write('SOURce:WAVElength:START {}'.format(λi))
        self.vel.write('SOURce:WAVElength:STOP {}'.format(λf))
        return print('λ_init = {} nm'.format(self.vel.query('SOURce:WAVElength:START?'))  + '\n' +  
                    'λ_final = {} nm'.format(self.vel.query('SOURce:WAVElength:STOP?')))
    def set_scan_speeds(self, forward, backward):
        # forward, backward in nm/s
        self.vel.write('SOURce:WAVE:SLEW:FORWard {}'.format(forward))
        self.vel.write('SOURce:WAVE:SLEW:RETurn {}'.format(backward))
        return print('Forward speed = {} nm/s'.format(self.vel.query('SOURce:WAVE:SLEW:FORWard?')) + '\n' + 
                    'Backward speed = {} nm/s'.format(self.vel.query('SOURce:WAVE:SLEW:RETurn?')))
    def reset_scan(self):
        self.vel.write('OUTPut:SCAN:RESET')
        self.waitUntilComplete()
        print('Reset finished')
    def start_scan(self):
        self.vel.write('OUTPut:SCAN:START')
        self.waitUntilComplete()
        print('Scan-up finished')
    def stop_scan(self):
        self.vel.write('OUTPut:SCAN:STOP')
    def set_ready(self):
        self.vel.write('OUTPut:TRACk OFF')
    def set_track(self):
        self.vel.write('OUTPut:TRACk ON')
    
        

if __name__ == '__main__':
    vel = Velocity(velNum=2, ifInitVpz=0)
    # vel.set_wvl(636.81)


    vel.set_current(66.5)
    # vel.set_scan_limits(635.3,638.7)
    # vel.set_scan_speeds(0.3,0.3)
    # vel.reset_scan()
    # vel.start_scan()
    # vel.reset_scan()

    # vel.set_track()
    # time.sleep(0.5)
    # vel.set_wvl(637.25)
    # time.sleep(1)
    # vel.set_ready()
    # vel.set_current(56.5)
    # vel.set_vpiezo(86.55)
    # vel.set_ready()

    # vel.meas_vpiezo()
    # vel.meas_wvl()
    # vel.meas_current()
    # vel.meas_power_front()