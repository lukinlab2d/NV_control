import pyvisa as visa
import sys
from qcodes.instrument.base import Instrument
from qcodes.instrument.parameter import Parameter
import numpy as np
import time

zero = ((0).to_bytes(2, 'little', signed=True)).decode("latin1")

def rest(ch1data, ch2data, num_restpoints):
    ch1data = np.concatenate((ch1data, np.zeros(num_restpoints, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(num_restpoints, dtype=np.int16)))
    return(ch1data, ch2data)

def pix(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, 32767*np.ones(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def piy(ch1data, ch2data, pitime, amp=32767):
    ch1data = np.concatenate((ch1data, np.zeros(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, amp*np.ones(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pix(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, -32768*np.ones(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def min_piy(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, np.zeros(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -32768*np.ones(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2x(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, 32767*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2y(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, np.zeros(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, 32767*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2special(ch1data, ch2data, pi2time, special_I, special_Q):
    ch1data = np.concatenate((ch1data, special_I*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, special_Q*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_special(ch1data, ch2data, pitime, special_I, special_Q):
    ch1data = np.concatenate((ch1data, special_I*np.ones(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, special_Q*np.ones(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2x(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, -32768*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2y(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, np.zeros(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -32768*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2special(ch1data, ch2data, pi2time, special_I, special_Q):
    ch1data = np.concatenate((ch1data, -1*special_I*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -1*special_Q*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def convert(ch1data, ch2data):
    ch1bin = ch1data.tobytes()
    ch2bin = ch2data.tobytes()
    ch1bin = ch1bin.decode("latin1")
    ch2bin = ch2bin.decode("latin1")
    return(ch1bin, ch2bin)

def unconvert(ch1bin, ch2bin):
    # Encode the strings back to bytes using "latin1"
    ch1bytes = ch1bin.encode("latin1")
    ch2bytes = ch2bin.encode("latin1")
    
    # Convert bytes back to NumPy arrays
    ch1data = np.frombuffer(ch1bytes, dtype=np.int16)  # Adjust dtype as needed
    ch2data = np.frombuffer(ch2bytes, dtype=np.int16)  # Adjust dtype as needed
    
    return ch1data, ch2data


class SDG6022X():
    def __init__(self, name='SDG6022X', SDGnum=1, settings=None, srate=None, **kwargs) -> None:
        rm = visa.ResourceManager()
        if SDGnum == 1:
            self.SDG = rm.open_resource('USB0::0xF4EC::0x1101::SDG6XFCC8R0037::INSTR')
            self.SDG.write("*RST")
            time.sleep(2)
            self.SDG.write("C1:BSWV HLEV,0.9861,LLEV,-0.9888") # calibrate IQ voltages 241003
            self.SDG.write("C2:BSWV HLEV,0.9855,LLEV,-0.9886")
            self.SDG.write("ROSC INT")
            self.SDG.write("ROSC 10MOUT,ON")
            # self.SDG.write("ROSC EXT")

        elif SDGnum == 2:
            self.SDG = rm.open_resource('USB0::0xF4EC::0x1101::SDG6XFCC8R0036::INSTR')
            self.SDG.write("*RST")
            time.sleep(2)
            self.SDG.write("C1:BSWV HLEV,0.9868,LLEV,-0.9881") # calibrate IQ voltages
            self.SDG.write("C2:BSWV HLEV,0.9914,LLEV,-0.9827")
            # time.sleep(2)
            self.SDG.write("ROSC EXT")
            # self.SDG.write("ROSC INT")
            # self.SDG.write("ROSC 10MOUT,ON")

        self.SDG.write("C1:BTWV STATE,ON,TRSR,EXT,EDGE,RISE,TIME,1,DLAY,0.00000145") # set to triggered mode
        self.SDG.write("C2:BTWV STATE,ON,TRSR,EXT,EDGE,RISE,TIME,1,DLAY,0.00000145")
        self.SDG.write("C1:WVDT WVNM,wave1,WAVEDATA,%s" % (zero), encoding='latin1') # set to arb mode with 0 output
        self.SDG.write("C1:ARWV NAME,wave1")
        self.SDG.write("C2:WVDT WVNM,wave2,WAVEDATA,%s" % (zero), encoding='latin1')
        self.SDG.write("C2:ARWV NAME,wave2")

        self.srate = srate
        if self.srate is not None:
            self.set_tarb(srate=srate)
        else:
            self.SDG.write("C1:SRATE MODE,DDS")
            self.SDG.write("C2:SRATE MODE,DDS")

        self.SDG.write("C1:OUTP ON") # turn on IQ outputs
        self.SDG.write("C2:OUTP ON")
        
    def upload_waveform(self, freq, ch1data, ch2data):
        self.SDG.write("C1:WVDT WVNM,wave1,FREQ," + str(freq) + ",WAVEDATA,%s" % (ch1data), encoding='latin1')
        self.SDG.write("C1:ARWV NAME,wave1")
        self.SDG.write("C2:WVDT WVNM,wave2,FREQ," + str(freq) + ",WAVEDATA,%s" % (ch2data), encoding='latin1')
        self.SDG.write("C2:ARWV NAME,wave2")
        
    def set_tarb(self,srate=300000000):
        self.SDG.write("C1:SRATE MODE,TARB,VALUE," + str(srate))
        self.SDG.write("C2:SRATE MODE,TARB,VALUE," + str(srate))

    def send_zero(self):
        psperiod = 1
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, 1)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_T1_seq(self, pitime, buffer):
        psperiod = 2*buffer + pitime
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pix(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_T2E_seq(self, pi_2time, pitime, tau, buffer, sig_to_ref_wait, 
                     special_I=0, special_Q=32767):
        psperiod = 2*buffer + 2*(2*pi_2time + 2*tau + pitime) + sig_to_ref_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        # ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        # ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, -1*special_I, -1*special_Q)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)

        return(ch1plot, ch2plot)
    
    def send_PhaseCheck_seq(self, pi_2time, pitime, tau, buffer, sig_to_ref_wait, special_I, special_Q):
        psperiod = 2*buffer + 2*(2*pi_2time + 2*tau + pitime) + sig_to_ref_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)

        return(ch1plot, ch2plot)
    
    def send_T2R_seq(self, pi_2time, tau, buffer, sig_to_ref_wait):
        psperiod = 2*buffer + 2*(2*pi_2time + tau) + sig_to_ref_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)
    
    def send_CalibRedRRIznRateWithIznPulse_seq(self, MWmix_duration, buffer,
                                               sig_to_ref_wait, ifPi=0, sig_to_pi_wait=0, pi_time=0,sleepTime=6):
        psperiod = 2*buffer + 2*MWmix_duration + sig_to_ref_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16) 
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)

        ch1data, ch2data = rest(ch1data, ch2data, int(buffer/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor))

        if ifPi==0:
            ch1data, ch2data = rest(ch1data, ch2data, int(sig_to_ref_wait/factor))

            ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor))
            ch1data, ch2data = rest(ch1data, ch2data, int(buffer/factor))
        else:
            pi_to_ref_wait = sig_to_ref_wait-sig_to_pi_wait-pi_time

            ch1data, ch2data = rest(ch1data, ch2data, int(sig_to_pi_wait/factor))
            ch1data, ch2data = piy(ch1data, ch2data, int(pi_time/factor))
            ch1data, ch2data = rest(ch1data, ch2data, int(pi_to_ref_wait/factor))
            ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor))
            ch1data, ch2data = rest(ch1data, ch2data, int(buffer/factor))
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)

    def send_SCCRRPhotonStatIrber_seq(self, MWmix_duration, buffer,
                                      sig_to_ref_wait, pitime, pi_to_MWmix_wait,shift_MW=0,sleepTime=6,amp_MW_mix=1):
        psperiod = 2*buffer + shift_MW+pitime + pi_to_MWmix_wait + 2*MWmix_duration + sig_to_ref_wait
        freq = 1e9/psperiod # doesn't mean anything
        ch1data = np.array([], dtype=np.int16) 
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)
            
        ch1data, ch2data = rest(ch1data, ch2data, int((buffer+shift_MW) / factor))
        # ch1data, ch2data = rest(ch1data, ch2data, int(pitime/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(pitime/factor))
        ch1data, ch2data = rest(ch1data, ch2data, int(pi_to_MWmix_wait/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor), amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, int(sig_to_ref_wait/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor), amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, int(buffer/factor))
        
        ch1plot = ch1data/32767; ch1plot = np.repeat(ch1plot,factor)
        ch2plot = ch2data/32767; ch2plot = np.repeat(ch2plot,factor)
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        # ch1debug, ch2debug = unconvert(ch1bindata, ch2bindata)
        # np.savetxt('C:/Users/lukin2dmaterials/miniconda3/envs/NV_control/B00_codes/ch1debug.txt', ch1debug, delimiter=',')
        # np.savetxt('C:/Users/lukin2dmaterials/miniconda3/envs/NV_control/B00_codes/ch2debug.txt', ch2debug, delimiter=',')
        # print(freq)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)
    
    def send_DrivenCorrSCCRRPhotonStatIrber_seq(self, MWmix_duration, buffer,
                                      sig_to_ref_wait, pulse_time, pulse_time_ref, pi_to_MWmix_wait,shift_MW=0,sleepTime=6,amp_MW_mix=1):
        psperiod = 2*buffer + shift_MW + pulse_time + pi_to_MWmix_wait + MWmix_duration + sig_to_ref_wait + pulse_time_ref + pi_to_MWmix_wait + MWmix_duration
        freq = 1e9/psperiod # doesn't mean anything
        ch1data = np.array([], dtype=np.int16) 
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)
            
        ch1data, ch2data = rest(ch1data, ch2data, int((buffer+shift_MW) / factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(pulse_time/factor))
        ch1data, ch2data = rest(ch1data, ch2data, int(pi_to_MWmix_wait/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor), amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, int(sig_to_ref_wait/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(pulse_time_ref/factor))
        ch1data, ch2data = rest(ch1data, ch2data, int(pi_to_MWmix_wait/factor))
        ch1data, ch2data = piy(ch1data, ch2data, int(MWmix_duration/factor), amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, int(buffer/factor))
        
        ch1plot = ch1data/32767; ch1plot = np.repeat(ch1plot,factor)
        ch2plot = ch2data/32767; ch2plot = np.repeat(ch2plot,factor)
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)

    def send_XY8SCCRRIrber_seq(self, MWmix_duration, buffer, 
                                      MWmix_to_pulseRef_wait, pitime, pulse_to_MWmix_wait,
                                      tau, numxy8, mode, ifAntiCorrel=0, ifJustRef_CorrACorr=0,
                                      shift_MW=0,sleepTime=6, rest_after_first_pulse = 40,
                                      special_I=0, special_Q=32767,AWGnum=0,
                                      special_I_antiCorrPulse=0, special_Q_antiCorrPulse=32767,
                                      tauExtra=0, amp_MW_mix=1):
        ################## first pulse is to prepare anticorrelation if any ########################################################
        pi_2time = pitime/2

        psperiod = 2*buffer + 2*(pitime + rest_after_first_pulse + shift_MW) + 2*(2*pi_2time + numxy8*tau*8 + numxy8*pitime*8) + 2*pulse_to_MWmix_wait + 2*MWmix_duration + MWmix_to_pulseRef_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)
        
        # convert all time to "point" in the byte string
        buffer = int(buffer/factor); pitime = int(pitime/factor); pi_2time = int(pi_2time/factor)
        rest_after_first_pulse = int(rest_after_first_pulse/factor); tauExtra = int(tauExtra/factor)
        shift_MW = int(shift_MW/factor); tau = int(tau/factor); MWmix_duration = int(MWmix_duration/factor)
        pulse_to_MWmix_wait = int(pulse_to_MWmix_wait/factor); MWmix_to_pulseRef_wait = int(MWmix_to_pulseRef_wait/factor)
        
        ################## Make first pulse + XY8 ################################################################################
        #################### signal #######################################
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        if ifAntiCorrel==1:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        
        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, MWmix_to_pulseRef_wait)

        #################### reference #######################################
        if ifAntiCorrel==AWGnum or ifJustRef_CorrACorr==AWGnum:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if ifJustRef_CorrACorr==0:    # flip the last pihalf pulse as usual
            if mode == 0:
                ch1data, ch2data = min_pi_2x(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, -1*special_I, -1*special_Q)
        else: # the last pihalf pulse is the same as sig, regardless of which NV
            if mode == 0:
                ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ###################### make array for plot and uploading ################################################################
        ch1plot = ch1data/32767; ch1plot = np.repeat(ch1plot,factor)
        ch2plot = ch2data/32767; ch2plot = np.repeat(ch2plot,factor)
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)
    
    def send_XY8DrivenCorrSCCRRIrber_seq(self, MWmix_duration, buffer, 
                                      MWmix_to_pulseRef_wait, pitime, pulse_to_MWmix_wait,
                                      tau, numxy8, mode, ifAntiCorrel=0, ifJustRef_CorrACorr=0,
                                      shift_MW=0,sleepTime=6, rest_after_first_pulse = 40,
                                      special_I=0, special_Q=32767,AWGnum=0,
                                      special_I_antiCorrPulse=0, special_Q_antiCorrPulse=32767,
                                      tauExtra=0, amp_MW_mix=1,pulse_time=40, pulse_time_ref=40,
                                      XY8_to_DC_delay=100):
        ################## first pulse is to prepare anticorrelation if any ########################################################
        pi_2time = pitime/2

        psperiod = 2*buffer + 2*(pitime + rest_after_first_pulse + shift_MW) + 2*(2*pi_2time + numxy8*tau*8 + numxy8*pitime*8 + XY8_to_DC_delay) + (pulse_time+pulse_time_ref) + 2*pulse_to_MWmix_wait + 2*MWmix_duration + MWmix_to_pulseRef_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)
        
        # convert all time to "point" in the byte string
        buffer = int(buffer/factor); pitime = int(pitime/factor); pi_2time = int(pi_2time/factor)
        rest_after_first_pulse = int(rest_after_first_pulse/factor); tauExtra = int(tauExtra/factor)
        shift_MW = int(shift_MW/factor); tau = int(tau/factor); MWmix_duration = int(MWmix_duration/factor)
        pulse_to_MWmix_wait = int(pulse_to_MWmix_wait/factor); MWmix_to_pulseRef_wait = int(MWmix_to_pulseRef_wait/factor)
        XY8_to_DC_delay = int(XY8_to_DC_delay/factor); pulse_time=int(pulse_time/factor); pulse_time_ref=int(pulse_time_ref/factor)
        ################## Make first pulse + XY8 ################################################################################
        #################### signal #######################################
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        if ifAntiCorrel==1:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        
        ch1data, ch2data = rest(ch1data, ch2data, XY8_to_DC_delay)
        ch1data, ch2data = piy(ch1data, ch2data, pulse_time)
        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, MWmix_to_pulseRef_wait)

        #################### reference #######################################
        if ifAntiCorrel==AWGnum or ifJustRef_CorrACorr==AWGnum:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if ifJustRef_CorrACorr==0:    # flip the last pihalf pulse as usual
            if mode == 0:
                ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        else: # the last pihalf pulse is the same as sig, regardless of which NV
            if mode == 0:
                ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, XY8_to_DC_delay)
        ch1data, ch2data = piy(ch1data, ch2data, pulse_time_ref)
        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ###################### make array for plot and uploading ################################################################
        ch1plot = ch1data/32767; ch1plot = np.repeat(ch1plot,factor)
        ch2plot = ch2data/32767; ch2plot = np.repeat(ch2plot,factor)
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)

    def send_AutoCorrXY8SCCRRIrber_seq(self, MWmix_duration, buffer, 
                                      MWmix_to_pulseRef_wait, pitime, pulse_to_MWmix_wait,
                                      tau, numxy8, mode, ifAntiCorrel=0, ifJustRef_CorrACorr=0,
                                      shift_MW=0,sleepTime=6, rest_after_first_pulse = 40,
                                      special_I=0, special_Q=32767,AWGnum=0,
                                      special_I_antiCorrPulse=0, special_Q_antiCorrPulse=32767,
                                      tauExtra=0, amp_MW_mix=1, tcorr=80):
        ################## first pulse is to prepare anticorrelation if any ########################################################
        pi_2time = pitime/2

        psperiod = 2*buffer + 2*(pitime + rest_after_first_pulse + shift_MW + 2*(2*pi_2time + numxy8*tau*8 + numxy8*pitime*8 + tauExtra) + tcorr + pulse_to_MWmix_wait + MWmix_duration) + MWmix_to_pulseRef_wait
        freq = 1e9/psperiod
        
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        if self.srate is not None:
            factor = 1e9/self.srate
        else:
            self.srate = int(250000000)
            self.set_tarb(srate=self.srate)
            print('SRate not pre-defined')
            factor = 1e9/self.srate
            time.sleep(10)
        
        # convert all time to "point" in the byte string
        buffer = int(buffer/factor); pitime = int(pitime/factor); pi_2time = int(pi_2time/factor)
        rest_after_first_pulse = int(rest_after_first_pulse/factor); tauExtra = int(tauExtra/factor)
        shift_MW = int(shift_MW/factor); tau = int(tau/factor); MWmix_duration = int(MWmix_duration/factor)
        pulse_to_MWmix_wait = int(pulse_to_MWmix_wait/factor); MWmix_to_pulseRef_wait = int(MWmix_to_pulseRef_wait/factor)
        tcorr = int(tcorr/factor)
        ################## Make first pulse + XY8 ################################################################################
        #################### signal #######################################
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        if ifAntiCorrel==1:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ### start XY8, first time ###
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ### end XY8, first time ###

        ch1data, ch2data = rest(ch1data, ch2data, tcorr)

        ### start XY8, second time ###
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ### end XY8, second time ###

        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, MWmix_to_pulseRef_wait)

        #################### reference #######################################
        if ifAntiCorrel==AWGnum or ifJustRef_CorrACorr==AWGnum:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ### start XY8, 3rd time ###
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ### end XY8, 3rd time ###

        ch1data, ch2data = rest(ch1data, ch2data, tcorr)

        ### start XY8, 4th time ###
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if ifJustRef_CorrACorr==0:    # flip the last pihalf pulse as usual
            if mode == 0:
                ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, -1*special_I, -1*special_Q)
        else: # the last pihalf pulse is the same as sig, regardless of which NV
            if mode == 0:
                ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ### end XY8, 4th time ###

        ch1data, ch2data = rest(ch1data, ch2data, pulse_to_MWmix_wait)
        ch1data, ch2data = piy(ch1data, ch2data, MWmix_duration, amp=int(amp_MW_mix*32767))
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ###################### make array for plot and uploading ################################################################
        ch1plot = ch1data/32767; ch1plot = np.repeat(ch1plot,factor)
        ch2plot = ch2data/32767; ch2plot = np.repeat(ch2plot,factor)
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        time.sleep(sleepTime)
        return(ch1plot, ch2plot)

    def send_T2R4point_seq(self, pi_2time, tau, buffer, sig_to_ref_wait):
        psperiod = 2*buffer + 4*(2*pi_2time + tau) + 3*sig_to_ref_wait
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_ODMR_seq(self, pulse_width, buffer):
        psperiod = 2*buffer + pulse_width
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pix(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_fastRabi_seq(self, pulse_width, buffer):
        psperiod = (buffer + (buffer - 1) + pulse_width)
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, int(2*buffer-2))
        ch1data, ch2data = piy(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, int(1))

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_Rabi_seq(self, pulse_width, buffer):
        psperiod = 2*buffer + pulse_width
        freq = 1e9/psperiod
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = piy(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_XY8_seq(self, pitime, pi_2time, tau, numxy8, buffer, sig_to_ref_wait, mode,
                     special_I=0, special_Q=32767,
                     ifAntiCorrel=0,AWGnum=0,ifJustRef_CorrACorr=0,rest_after_first_pulse=80,shift_MW=0,
                     last_pi_2time=0,special_I_antiCorrPulse=0, special_Q_antiCorrPulse=32767,
                     tauExtra=0): # mode = 0: cos mag, mode = 1: sin mag
        
        if last_pi_2time==0: last_pi_2time=pi_2time
        psperiod = 2*buffer + 2*(pitime + rest_after_first_pulse + shift_MW + (last_pi_2time + pi_2time) + numxy8*tau*8 + numxy8*pitime*8) + sig_to_ref_wait
        freq = 1e9/psperiod

        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ################################# signal ####################################################
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        if ifAntiCorrel==1:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2x(ch1data, ch2data, last_pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)
        ################################# reference ####################################################

        if ifAntiCorrel==AWGnum or ifJustRef_CorrACorr==AWGnum:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if ifJustRef_CorrACorr==0:    # flip the last pihalf pulse as usual
            if mode == 0:
                ch1data, ch2data = min_pi_2x(ch1data, ch2data, last_pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, -1*special_I, -1*special_Q)
        else: # the last pihalf pulse is the same as sig, regardless of which NV
            if mode == 0:
                ch1data, ch2data = pi_2x(ch1data, ch2data, last_pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)  

        return(ch1plot, ch2plot)
    
    def send_AutoCorrXY8_seq(self, pitime, pi_2time, tau, numxy8, buffer, sig_to_ref_wait, mode,
                     special_I=0, special_Q=32767,
                     ifAntiCorrel=0,AWGnum=0,ifJustRef_CorrACorr=0,rest_after_first_pulse=80,shift_MW=0,
                     last_pi_2time=0,special_I_antiCorrPulse=0, special_Q_antiCorrPulse=32767,
                     tauExtra=0,tcorr=80): # mode = 0: cos mag, mode = 1: sin mag
        
        if last_pi_2time==0: last_pi_2time=pi_2time
        psperiod = 2*buffer + 2*(pitime + rest_after_first_pulse + shift_MW + 2*(last_pi_2time + pi_2time + numxy8*tau*8 + numxy8*pitime*8 + tauExtra)+tcorr) + sig_to_ref_wait
        freq = 1e9/psperiod

        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ################################# signal ####################################################
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        if ifAntiCorrel==1:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ## start XY8, first time
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, last_pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)
        ## end XY8, first time

        ch1data, ch2data = rest(ch1data, ch2data, tcorr)

        ## start XY8, second time
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, last_pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)
        ## end XY8, second time

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)
        ################################# reference ####################################################

        if ifAntiCorrel==AWGnum or ifJustRef_CorrACorr==AWGnum:
            ch1data, ch2data = pi_special(ch1data, ch2data, pitime, special_I_antiCorrPulse, special_Q_antiCorrPulse)
        else:
            ch1data, ch2data = rest(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, rest_after_first_pulse + shift_MW)

        ## start XY8, 3rd time
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, last_pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)
        ## end XY8, 3rd time

        ch1data, ch2data = rest(ch1data, ch2data, tcorr)

        ## start XY8, 4th time
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2+tauExtra))

        if ifJustRef_CorrACorr==0:    # flip the last pihalf pulse as usual
            if mode == 0:
                ch1data, ch2data = min_pi_2y(ch1data, ch2data, last_pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, -1*special_I, -1*special_Q)
        else: # the last pihalf pulse is the same as sig, regardless of which NV
            if mode == 0:
                ch1data, ch2data = pi_2y(ch1data, ch2data, last_pi_2time)
            elif mode == 1:
                ch1data, ch2data = pi_2special(ch1data, ch2data, last_pi_2time, special_I, special_Q)
        ## end XY8, 4th time

        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)  

        return(ch1plot, ch2plot)
    
    def turn_off(self):
        self.SDG.write("C1:OUTP OFF")
        self.SDG.write("C2:OUTP OFF")