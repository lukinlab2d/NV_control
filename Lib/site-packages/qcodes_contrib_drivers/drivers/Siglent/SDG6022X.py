import pyvisa as visa
import sys
from qcodes.instrument.base import Instrument
from qcodes.instrument.parameter import Parameter
import numpy as np

zero = ((0).to_bytes(2, 'little', signed=True)).decode("latin1")

def rest(ch1data, ch2data, num_restpoints):
    ch1data = np.concatenate((ch1data, np.zeros(num_restpoints, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(num_restpoints, dtype=np.int16)))
    return(ch1data, ch2data)

def pix(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, 32767*np.ones(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def piy(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, np.zeros(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, 32767*np.ones(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pix(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, -32768*np.ones(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def min_piy(ch1data, ch2data, pitime):
    ch1data = np.concatenate((ch1data, np.zeros(pitime, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -32768*np.ones(pitime, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2x(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, 32767*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2y(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, np.zeros(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, 32767*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def pi_2special(ch1data, ch2data, pi2time, special_I, special_Q):
    ch1data = np.concatenate((ch1data, special_I*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, special_Q*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2x(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, -32768*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, np.zeros(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2y(ch1data, ch2data, pi2time):
    ch1data = np.concatenate((ch1data, np.zeros(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -32768*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def min_pi_2special(ch1data, ch2data, pi2time, special_I, special_Q):
    ch1data = np.concatenate((ch1data, -1*special_I*np.ones(pi2time, dtype=np.int16)))
    ch2data = np.concatenate((ch2data, -1*special_Q*np.ones(pi2time, dtype=np.int16)))
    return(ch1data, ch2data)

def convert(ch1data, ch2data):
    ch1bin = ch1data.tobytes()
    ch2bin = ch2data.tobytes()
    ch1bin = ch1bin.decode("latin1")
    ch2bin = ch2bin.decode("latin1")
    return(ch1bin, ch2bin)



class SDG6022X():
    def __init__(self, name='SDG6022X', SDGnum=1, settings=None, **kwargs) -> None:
        rm = visa.ResourceManager()
        if SDGnum == 1:
            self.SDG = rm.open_resource('USB0::0xF4EC::0x1101::SDG6XFCC8R0037::INSTR')
            
            self.SDG.write("C1:BSWV HLEV,0.9846,LLEV,-0.9903") # calibrate IQ voltages
            self.SDG.write("C2:BSWV HLEV,0.9839,LLEV,-0.9902")
            # self.SDG.write("C1:BSWV HLEV,0.9876,LLEV,-0.9903") # calibrate IQ voltages
            # self.SDG.write("C2:BSWV HLEV,0.9871,LLEV,-0.9902")
            self.SDG.write("C1:BTWV STATE,ON,TRSR,EXT,TIME,1") # set to triggered mode
            self.SDG.write("C2:BTWV STATE,ON,TRSR,EXT,TIME,1")
            self.SDG.write("C1:WVDT WVNM,wave1,WAVEDATA,%s" % (zero), encoding='latin1') # set to arb mode with 0 output
            self.SDG.write("C1:ARWV NAME,wave1")
            self.SDG.write("C2:WVDT WVNM,wave2,WAVEDATA,%s" % (zero), encoding='latin1')
            self.SDG.write("C2:ARWV NAME,wave2")
            self.SDG.write("C1:OUTP ON") # turn on IQ outputs
            self.SDG.write("C2:OUTP ON")
        # elif SDGnum == 2:
        #     self.SDG = rm.open_resource('')
        #     self.SDG.query('*IDN?')

    def upload_waveform(self, freq, ch1data, ch2data):
        self.SDG.write("C1:WVDT WVNM,wave1,FREQ," + str(freq) + ",WAVEDATA,%s" % (ch1data), encoding='latin1')
        self.SDG.write("C1:ARWV NAME,wave1")
        self.SDG.write("C2:WVDT WVNM,wave2,FREQ," + str(freq) + ",WAVEDATA,%s" % (ch2data), encoding='latin1')
        self.SDG.write("C2:ARWV NAME,wave2")

    def send_zero(self):
        psperiod = 1
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, 1)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_T1_seq(self, pitime, buffer):
        psperiod = 2*buffer + pitime
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pix(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_T2E_seq(self, pi_2time, pitime, tau, buffer, sig_to_ref_wait, 
                     special_I=0, special_Q=32767):
        psperiod = 2*buffer + 2*(2*pi_2time + 2*tau + pitime) + sig_to_ref_wait
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        # ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        # ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, -1*special_I, -1*special_Q)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)

        return(ch1plot, ch2plot)
    
    def send_PhaseCheck_seq(self, pi_2time, pitime, tau, buffer, sig_to_ref_wait, special_I, special_Q):
        psperiod = 2*buffer + 2*(2*pi_2time + 2*tau + pitime) + sig_to_ref_wait
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = piy(ch1data, ch2data, pitime)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2special(ch1data, ch2data, pi_2time, special_I, special_Q)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)

        self.upload_waveform(freq, ch1bindata, ch2bindata)

        return(ch1plot, ch2plot)
    
    def send_T2R_seq(self, pi_2time, tau, buffer, sig_to_ref_wait):
        psperiod = 2*buffer + 2*(2*pi_2time + tau) + sig_to_ref_wait
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_T2R4point_seq(self, pi_2time, tau, buffer, sig_to_ref_wait):
        psperiod = 2*buffer + 4*(2*pi_2time + tau) + 3*sig_to_ref_wait
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, tau)
        ch1data, ch2data = min_pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        
        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_ODMR_seq(self, pulse_width, buffer):
        psperiod = 2*buffer + pulse_width
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pix(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_fastRabi_seq(self, pulse_width, buffer):
        psperiod = (buffer + buffer - 1 + pulse_width)
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, int(2*buffer-2))
        ch1data, ch2data = piy(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, int(1))

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_Rabi_seq(self, pulse_width, buffer):
        psperiod = 2*buffer + pulse_width
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = piy(ch1data, ch2data, pulse_width)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)
        return(ch1plot, ch2plot)

    def send_XY8_seq(self, pitime, pi_2time, tau, numxy8, buffer, sig_to_ref_wait, mode): # mode = 0: cos mag, mode = 1: sin mag
        psperiod = 2*buffer + 2*(2*pi_2time + numxy8*tau*8 + numxy8*pitime*8) + sig_to_ref_wait
        freq = (1/psperiod)*1e9
        ch1data = np.array([], dtype=np.int16)
        ch2data = np.array([], dtype=np.int16)

        ch1data, ch2data = rest(ch1data, ch2data, buffer)
        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)
                       
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        if mode == 0:
            ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = pi_2x(ch1data, ch2data, pi_2time)

        ch1data, ch2data = rest(ch1data, ch2data, sig_to_ref_wait)

        ch1data, ch2data = pi_2y(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))

        for i in range(int(numxy8)):
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = piy(ch1data, ch2data, pitime)
            ch1data, ch2data = rest(ch1data, ch2data, tau)
            ch1data, ch2data = pix(ch1data, ch2data, pitime)
            if i<(numxy8-1):
                ch1data, ch2data = rest(ch1data, ch2data, tau)

        ch1data, ch2data = rest(ch1data, ch2data, int(tau/2))
                
        if mode == 0:
            ch1data, ch2data = min_pi_2y(ch1data, ch2data, pi_2time)
        elif mode == 1:
            ch1data, ch2data = min_pi_2x(ch1data, ch2data, pi_2time)
        ch1data, ch2data = rest(ch1data, ch2data, buffer)

        ch1plot = ch1data/32767
        ch2plot = ch2data/32767
        ch1bindata, ch2bindata = convert(ch1data, ch2data)
        
        self.upload_waveform(freq, ch1bindata, ch2bindata)  

        return(ch1plot, ch2plot)
    
    def turn_off(self):
        self.SDG.write("C1:OUTP OFF")
        self.SDG.write("C2:OUTP OFF")