"""
Qcodes drivers for National Instrument mutlifunction I/O devices (DAQs).

Requires nidaqmx package: https://nidaqmx-python.readthedocs.io/en/latest/

This was written for/tested with National Instruments USB-6363 DAQ,
but the nidaqmx API is pretty general, so I expect it will work with other devices
with minimal changes.

For an example of synchronously writing data to multiple analog outputs and
acquiring data on multiple analog inputs, see
https://scanning-squid.readthedocs.io/en/latest/_modules/microscope/susceptometer.html#SusceptometerMicroscope.scan_surface
"""

from ast import Param
from random import sample
from typing import Dict, Optional, Sequence, Any, Union
import numpy as np

import nidaqmx
import time
from nidaqmx.constants import AcquisitionType #, TaskMode # not used?
from qcodes.instrument.base import Instrument
from qcodes.instrument.parameter import Parameter, ArrayParameter
#from qcodes.utils.helpers import create_on_off_val_mapping # not used?
from nidaqmx.constants import(
    #LineGrouping, # note used?
    Edge,
    CountDirection,
    AcquisitionType,
    FrequencyUnits
)

# TODO: remove unused imports

################################################ ANALOG I/O ######################################################
# AI    
class DAQAnalogInputs(Instrument):
    """Instrument to acquire DAQ analog input data in a qcodes Loop or measurement.

    Args:
        name: Name of instrument (usually 'daq_ai').
        dev_name: NI DAQ device name (e.g. 'Dev1').
        rate: Desired DAQ sampling rate per channel in Hz.
        channels: Dict of analog input channel configuration.
        task: fresh nidaqmx.Task to be populated with ai_channels.
        min_val: minimum of input voltage range (-0.1, -0.2, -0.5, -1, -2, -5 [default], or -10)
        max_val: maximum of input voltage range (0.1, 0.2, 0.5, 1, 2, 5 [default], or 10)
        clock_src: Sample clock source for analog inputs. Default: None
        samples_to_read: Number of samples to acquire from the DAQ
            per channel per measurement/loop iteration.
            Default: 2 (minimum number of samples DAQ will acquire in this timing mode).
        target_points: Number of points per channel we want in our final array.
            samples_to_read will be averaged down to target_points.
        timeout: Acquisition timeout in seconds. Default: 60.
        kwargs: Keyword arguments to be passed to Instrument constructor.
    """
    def __init__(self, name: str, dev_name: str, rate: Union[int, float], channels: Dict[str, int],
                 task: Any, min_val: Optional[float]=-5, max_val: Optional[float]=5,
                 clock_src: Optional[str]=None, samples_to_read: Optional[int]=2,
                 target_points: Optional[int]=None, timeout: Optional[Union[float, int]]=60, **kwargs) -> None:
        super().__init__(name, **kwargs)
        if target_points is None:
            if samples_to_read == 2: # minimum number of samples DAQ will read in this timing mode
                target_points = 1
            else:
                target_points = samples_to_read
        self.rate = rate
        nchannels = len(channels)
        self.samples_to_read = samples_to_read
        self.task = task
        self.metadata.update({
            'dev_name': dev_name,
            'rate': f'{rate} Hz',
            'channels': channels})
        for ch, idx in channels.items():
            channel = f'{dev_name}/ai{idx}'
            self.task.ai_channels.add_ai_voltage_chan(channel, ch, min_val=min_val, max_val=max_val)
        if clock_src is None:
            # Use default sample clock timing: ai/SampleClockTimebase
            self.task.timing.cfg_samp_clk_timing(
                rate,
                sample_mode=AcquisitionType.FINITE,
                samps_per_chan=samples_to_read)
        else:
            # Clock the inputs on some other clock signal, e.g. ao/SampleClock for synchronous acquisition
            self.task.timing.cfg_samp_clk_timing(
                    rate,
                    source=clock_src,
                    sample_mode=AcquisitionType.FINITE,
                    samps_per_chan=samples_to_read
            )
        # We need a parameter in order to acquire voltage in a qcodes Loop or Measurement
        self.add_parameter(
            name='voltage',
            parameter_class=DAQAnalogInputVoltage,
            task=self.task,
            samples_to_read=samples_to_read,
            shape=(nchannels, target_points),
            timeout=timeout,
            label='Voltage',
            unit='V'
        ) 

# AI extra
class DAQAnalogInputVoltage(ArrayParameter):
    """Acquires data from one or several DAQ analog inputs.

    Args:
        name: Name of parameter (usually 'voltage').
        task: nidaqmx.Task with appropriate analog inputs channels.
        samples_to_read: Number of samples to read. Will be averaged based on shape.
        shape: Desired shape of averaged array, i.e. (nchannels, target_points).
        timeout: Acquisition timeout in seconds.
        kwargs: Keyword arguments to be passed to ArrayParameter constructor.
    """
    def __init__(self, name: str, task: Any, samples_to_read: int,
                 shape: Sequence[int], timeout: Union[float, int], **kwargs) -> None:
        super().__init__(name, shape, **kwargs)
        self.task = task
        self.nchannels, self.target_points = shape
        self.samples_to_read = samples_to_read
        self.timeout = timeout
        
    def get_raw(self):
        """Averages data to get `self.target_points` points per channel.
        If `self.target_points` == `self.samples_to_read`, no averaging is done.
        """
        data_raw = np.array(self.task.read(number_of_samples_per_channel=self.samples_to_read, timeout=self.timeout))
        return np.mean(np.reshape(data_raw, (self.nchannels, self.target_points, -1)), 2)

# AO
class DAQAnalogOutputs(Instrument):
    """Instrument to write DAQ analog output data in a qcodes Loop or measurement.

    Args:
        name: Name of instrument (usually 'daq_ao').
        dev_name: NI DAQ device name (e.g. 'Dev1').
        channels: Dict of analog output channel configuration.
        **kwargs: Keyword arguments to be passed to Instrument constructor.
    """
    def __init__(self, name: str, dev_name: str, channels: Dict[str, int], **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.metadata.update({
            'dev_name': dev_name,
            'channels': channels})
        # We need parameters in order to write voltages in a qcodes Loop or Measurement
        for ch, idx in channels.items():
            self.add_parameter(
                name=f'voltage_{"".join(c for c in ch.lower() if c.isalnum())}',
                # name = f'voltage_{ch.lower}',
                dev_name=dev_name,
                idx=idx,
                parameter_class=DAQAnalogOutputVoltage,
                label='Voltage',
                unit='V'
            )
        #print("name: "+name)

# AO extra
class DAQAnalogOutputVoltage(Parameter):
    """Writes data to one or several DAQ analog outputs. This only writes one channel at a time,
    since Qcodes ArrayParameters are not settable.

    Args:
        name: Name of parameter (usually 'voltage').
        dev_name: DAQ device name (e.g. 'Dev1').
        idx: AO channel index.
        kwargs: Keyword arguments to be passed to ArrayParameter constructor.
    """
    def __init__(self, name: str, dev_name: str, idx: int, **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.dev_name = dev_name
        self.idx = idx
        self._voltage = np.nan
     
    def set_raw(self, voltage: Union[int, float]) -> None:
        with nidaqmx.Task('daq_ao_task') as ao_task:
            channel = f'{self.dev_name}/ao{self.idx}'
            ao_task.ao_channels.add_ao_voltage_chan(channel, self.name)
            ao_task.write(voltage, auto_start=True)
        self._voltage = voltage

    def get_raw(self):
        """Returns last voltage array written to outputs.
        """
        return self._voltage

############################################### DIGITAL I/O ######################################################
# DI
class DAQDigitalInputs(Instrument):
    """Instrument to acquire DAQ digital input data in a qcodes Loop or measurement.
    Args:
        name: Name of instrument (usually 'daq_ai').
        dev_name: NI DAQ device name (e.g. 'Dev1').
        rate: Desired DAQ sampling rate per channel in Hz.
        channels: Dict of digital input channel configuration.
        task: fresh nidaqmx.Task to be populated with di_channels.
        clock_src: Sample clock source for digital inputs. Default: None
        samples_to_read: Number of samples to acquire from the DAQ
            per channel per measurement/loop iteration.
            Default: 2 (minimum number of samples DAQ will acquire in this timing mode).
        target_points: Number of points per channel we want in our final array.
            samples_to_read will be averaged down to target_points.
        timeout: Acquisition timeout in seconds. Default: 60.
        kwargs: Keyword arguments to be passed to Instrument constructor.
    """
    def __init__(self, name: str, dev_name: str, rate: Union[int, float], channels: Dict[str, int],
                 task: Any, clock_src: Optional[str]=None, samples_to_read: Optional[int]=2,
                 target_points: Optional[int]=None, timeout: Optional[Union[float, int]]=60, **kwargs) -> None:
        super().__init__(name, **kwargs)
        if target_points is None:
            if samples_to_read == 2: # minimum number of samples DAQ will read in this timing mode
                target_points = 1
            else:
                target_points = int(samples_to_read)
        self.rate = rate
        nchannels = len(channels)
        self.samples_to_read = int(samples_to_read)
        self.task = task
        self.metadata.update({
            'dev_name': dev_name,
            'rate': f'{rate} Hz',
            'channels': channels})
        for ch, idx in channels.items():
            #print(idx, ch)
            # channel = f'%s_port0_line{"".join(c for c in str(idx).lower() if c.isalnum())}'%(dev_name)
            channel = f'{dev_name}/{ch}'
            # print(channel)
            self.task.di_channels.add_di_chan(channel)
            # print("tasks added")
        if clock_src is None:
            # Use default sample clock timing: di/SampleClockTimebase
            self.task.timing.cfg_samp_clk_timing(
                int(rate),
                sample_mode=AcquisitionType.FINITE,
                samps_per_chan=int(samples_to_read))
        else:
            # Clock the inputs on some other clock signal, e.g. ao/SampleClock for synchronous acquisition
            self.task.timing.cfg_samp_clk_timing(
                    rate,
                    source=clock_src,
                    sample_mode=AcquisitionType.FINITE,
                    samps_per_chan=int(samples_to_read)
            )
        # We need a parameter in order to acquire voltage in a qcodes Loop or Measurement
        self.add_parameter(
            name='voltage',
            parameter_class=DAQDigitalInputVoltage,
            task=self.task,
            samples_to_read=int(samples_to_read),
            shape=(nchannels, int(target_points)),
            timeout=timeout,
            label='Voltage',
            unit='V'
        )

# DI extra
class DAQDigitalInputVoltage(ArrayParameter):
    """Acquires data from one or several DAQ digital inputs.
    Args:
        name: Name of parameter (usually 'voltage').
        task: nidaqmx.Task with appropriate digital inputs channels.
        samples_to_read: Number of samples to read. Will be averaged based on shape.
        shape: Desired shape of averaged array, i.e. (nchannels, target_points).
        timeout: Acquisition timeout in seconds.
        kwargs: Keyword arguments to be passed to ArrayParameter constructor.
    """
    def __init__(self, name: str, task: Any, samples_to_read: int,
                 shape: Sequence[int], timeout: Union[float, int], **kwargs) -> None:
        super().__init__(name, shape, **kwargs)
        self.task = task
        self.nchannels, self.target_points = shape
        self.samples_to_read = samples_to_read
        self.timeout = timeout
        
    def get_raw(self):
        """Averages data to get `self.target_points` points per channel.
        If `self.target_points` == `self.samples_to_read`, no averaging is done.
        """
        data_raw = np.array(self.task.read(number_of_samples_per_channel=self.samples_to_read, timeout=self.timeout))
        return np.mean(np.reshape(data_raw, (self.nchannels, self.target_points, -1)), 2)

# DO
class DAQDigitalOutputs(Instrument):
    pass

# DO extra
class DAQDigitalOutputVoltage(Parameter):
    pass

################################################## COUNTERS ######################################################
# creating counter class
class Counter(Instrument):
    """
    instrument to count incoming rising edges of a digital signal for the NI cDAQ series 9402 module

    Args:
        name: choice name of the instrument (can be "my_instrument" for ex.)
        device_name: name of the actual device (can be "cDAQ1Mod1" for ex.)
        counter_channel: the str name of the module's channel you want to count on
        clock_channel: the str name of the channel you want to use as the clock
        source_channel: the str name of channel you are using as the clock source
        sampling_rate: the sampling rate for acquisition in Hz
        samples_per_channel: the desired number of samples to acquire (int)
        duty_cycle: the duty cycle value desired for sampling (int)
        integration_time: int
        timeout: int
        **kwargs
    """
    
    def __init__(self, name: str, device_name: str, counter_channel: Dict[str, int], clock_channel: Dict[str, int],
        source_channel: Dict[str, int], sampling_rate: int, samples_per_channel: int, duty_cycle: int, integration_time: int,
        timeout: int, **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.metadata.update({
            "device_name": device_name,
            "counter_channel": counter_channel,
            "clock_channel": clock_channel,
            "source_channel": source_channel,
            "sampling_rate": sampling_rate,
            "samples_per_channel": samples_per_channel,
            "duty_cycle": duty_cycle,
            "integration_time": integration_time,
            "timeout": timeout
        })

        # parameter "Read_Counter"
        self.add_parameter(
            name = f'read_counter_{"".join(c for c in counter_channel.lower() if c.isalnum())}',
            device_name = device_name,
            counter_channel = counter_channel,
            clock_channel = clock_channel,
            source_channel = source_channel,
            sampling_rate = sampling_rate,
            samples_per_channel = samples_per_channel,
            duty_cycle = duty_cycle,
            integration_time = integration_time,
            timeout = timeout,
            parameter_class = Read_Counter,
            label = "Counter",
            unit = "#",
            set_cmd = ""
        )

        # parameter "integrateavg"
        self.add_parameter(
            name = "integrateavg",
            device_name = device_name,
            counter_channel = counter_channel,
            clock_channel = clock_channel,
            source_channel = source_channel,
            sampling_rate = sampling_rate,
            samples_per_channel = samples_per_channel,
            duty_cycle = duty_cycle,
            integration_time = integration_time,
            timeout = timeout,
            parameter_class = integrateavg,
            label = "Counter",
            unit = "#",
            set_cmd = ""
        )

# reading counter parameter (CI extra)
class Read_Counter(Parameter):
    """
    program from ipynb file in Jupyter

    Args:
        name: str
        device_name: str
        counter_channel: str
        clock_channel: str
        source_channel: str
        sampling_rate: int
        samples_per_channel: int
        duty_cycle: int
        integration_time: int
        timeout: int
        kwargs: keyword arguments to be passed to the instrument constructor
    """

    # main fnc?
    def __init__(self, name: str, device_name: str, counter_channel: str, clock_channel: str, source_channel: str,
        sampling_rate: int, samples_per_channel: int, duty_cycle: int, integration_time: int, timeout: int, **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.device_name = device_name
        self.counter_channel = counter_channel
        self.clock_channel = clock_channel
        self.source_channel = source_channel
        self.sampling_rate = sampling_rate
        self.samples_per_channel = samples_per_channel
        self.duty_cycle = duty_cycle
        self.integration_time = integration_time
        self.timeout = timeout
        self.read_counter_value = np.nan # is this line correct?

    # getting; reading the counter value
    def get_raw(self):
        with nidaqmx.Task() as task1, nidaqmx.Task() as counter_output_task:

            # adding dig pulse train chan
            counter_output_task.co_channels.add_co_pulse_chan_freq(
                counter = self.clock_channel,
                name_to_assign_to_channel = "",
                units = FrequencyUnits.HZ,
                idle_state = nidaqmx.constants.Level.LOW,
                initial_delay = 0.0,
                freq = self.sampling_rate,
                duty_cycle = self.duty_cycle
                )

            # cfg implict timing
            counter_output_task.timing.cfg_implicit_timing(
                sample_mode = AcquisitionType.CONTINUOUS,
                samps_per_chan = self.samples_per_channel,
                )

            # adding count egdes chan
            task1.ci_channels.add_ci_count_edges_chan(
                counter = self.counter_channel,
                name_to_assign_to_channel = "",
                edge = Edge.RISING,
                initial_count = 0,
                count_direction = CountDirection.COUNT_UP
                )

            # cfg sample clk tiing
            task1.timing.cfg_samp_clk_timing(
                rate = self.sampling_rate,
                source = self.source_channel,
                active_edge = Edge.RISING,
                sample_mode = AcquisitionType.CONTINUOUS,
                samps_per_chan = self.samples_per_channel
                )
                
            counter_output_task.start()
            task1.start()
            # read number: samples_per_channel as def
            counter_value = task1.read(self.samples_per_channel)
        
        # print("hello")
        return float(str(counter_value)[1])

# reading counter parameter (CI extra 2)
class integrateavg(Parameter):
    """
    program from ipynb file in Jupyter

    Args:
        name: str
        device_name: str
        counter_channel: str
        clock_channel: str
        source_channel: str
        sampling_rate: int
        samples_per_channel: int
        duty_cycle: int
        integration_time: int
        timeout: int
        kwargs: keyword arguments to be passed to the instrument constructor
    """

    # main fnc?
    def __init__(self, name: str, device_name: str, counter_channel: str, clock_channel: str, source_channel: str,
        sampling_rate: int, samples_per_channel: int, duty_cycle: int, integration_time: int, timeout: int, **kwargs) -> None:
        super().__init__(name, **kwargs)
        self.device_name = device_name
        self.counter_channel = counter_channel
        self.clock_channel = clock_channel
        self.source_channel = source_channel
        self.sampling_rate = sampling_rate
        self.samples_per_channel = samples_per_channel
        self.duty_cycle = duty_cycle
        self.integration_time = integration_time
        self.timeout = timeout
        self.read_counter_value = np.nan # is this line correct?

    # getting; reading the counter value
    def get_raw(self):
        with nidaqmx.Task() as task1, nidaqmx.Task() as counter_output_task:

            # adding dig pulse train chan
            counter_output_task.co_channels.add_co_pulse_chan_freq(
                counter = self.clock_channel,
                name_to_assign_to_channel = "",
                units = FrequencyUnits.HZ,
                idle_state = nidaqmx.constants.Level.LOW,
                initial_delay = 0.0,
                freq = self.sampling_rate,
                duty_cycle = self.duty_cycle
                )

            # cfg implict timing
            counter_output_task.timing.cfg_implicit_timing(
                sample_mode = AcquisitionType.CONTINUOUS,
                samps_per_chan = self.samples_per_channel,
                )

            # adding count egdes chan
            task1.ci_channels.add_ci_count_edges_chan(
                counter = self.counter_channel,
                name_to_assign_to_channel = "",
                edge = Edge.RISING,
                initial_count = 0,
                count_direction = CountDirection.COUNT_UP
                )

            # cfg sample clk tiing
            task1.timing.cfg_samp_clk_timing(
                rate = self.sampling_rate,
                source = self.source_channel,
                active_edge = Edge.RISING,
                sample_mode = AcquisitionType.CONTINUOUS,
                samps_per_chan = self.samples_per_channel
                )
                
            counter_output_task.start()
            task1.start()
     
            # output = 0
            # time_start = time.time()
            # timeout = time_start + self.integration_time
            # while time.time() < timeout:
            #     output = task1.read()
            
            n_samples = int(self.integration_time * self.sampling_rate)
            output = task1.read(n_samples)

            counter_output_task.stop()
            task1.stop()
            return (output[-1] - output[0])/self.integration_time
            

            # for f in range(100):
            #     one_value = task1.read(1)
            #     output += int(str(one_value)[1])
            # return output